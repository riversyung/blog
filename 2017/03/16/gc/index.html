<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="垃圾收集(GC)"/>




  <meta name="keywords" content="JVM," />





  <link rel="alternate" href="/default" title="Rivers">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://yoursite.com/2017/03/16/gc/"/>


<meta name="description" content="概述垃圾收集 Garbage CollectionJVM 中不同区域的回收方式不同  

程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭
帧栈随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理
GC主要集中于Java堆和方法区（Method Area），在程序运行期间，这部分内存的分配和使用都是动态的

JVM堆结构Heap = {Old + New ={Eden, from,">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾收集(GC)">
<meta property="og:url" content="http://yoursite.com/2017/03/16/gc/index.html">
<meta property="og:site_name" content="Rivers">
<meta property="og:description" content="概述垃圾收集 Garbage CollectionJVM 中不同区域的回收方式不同  

程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭
帧栈随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理
GC主要集中于Java堆和方法区（Method Area），在程序运行期间，这部分内存的分配和使用都是动态的

JVM堆结构Heap = {Old + New ={Eden, from,">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174234266-1575111287.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174237703-328169343.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239219-1187241876.png">
<meta property="og:updated_time" content="2017-03-16T08:05:06.069Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="垃圾收集(GC)">
<meta name="twitter:description" content="概述垃圾收集 Garbage CollectionJVM 中不同区域的回收方式不同  

程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭
帧栈随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理
GC主要集中于Java堆和方法区（Method Area），在程序运行期间，这部分内存的分配和使用都是动态的

JVM堆结构Heap = {Old + New ={Eden, from,">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174234266-1575111287.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 垃圾收集(GC) - Rivers </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Rivers</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          垃圾收集(GC)
        
      </h1>

      <time class="post-time">
          Mar 16 2017
      </time>
    </header>



    
            <div class="post-content">
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>垃圾收集 Garbage Collection<br>JVM 中不同区域的回收方式不同  </p>
<ul>
<li>程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭</li>
<li>帧栈随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理</li>
<li>GC主要集中于Java堆和方法区（Method Area），在程序运行期间，这部分内存的分配和使用都是动态的</li>
</ul>
<h2 id="JVM堆结构"><a href="#JVM堆结构" class="headerlink" title="JVM堆结构"></a>JVM堆结构</h2><p>Heap = {Old + New ={Eden, from, to}}   </p>
<h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><ul>
<li>所有新生成的对象首先都是放在新生代</li>
<li>新生代的目标就是尽可能快速地收集掉那些生命周期短的对象</li>
<li>年轻代分为3个区， 1个Eden区，2个Srivivor区（from 和 to）</li>
<li>大部分对象在Eden区中生成。 当Eden区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Surivivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到“年老区（Tenured）”</li>
<li>两个Survivor区是对称的，没有先后关系。所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor区过来的对象。而且，Survivor区总有一个是空的（<em>因为Sruvivor区分为两个区，在复制的时候，从So到Si复制完以后，So区里面的对象将被释放掉，等待下一次YGC时再进行交换，所以从Si到So每次总有一个S区是空的</em>）</li>
<li>针对年轻代的GC称为 Minor GC 或Young GC</li>
</ul>
<h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><ul>
<li>在年轻代中经历了N次（可配置）垃圾回收后，仍然存活的对象，就会被复制到年老代（Old，Tenure），因此可以认为，年老代中存放的都是一些生命周期较长的对象。</li>
<li>针对年老代的GC称为 Major GC或者Full GC</li>
</ul>
<h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><ul>
<li>永久代PermGen space。它并不在Java堆。有时又被称为元空间（Metaspace）或方法区（Method Area）。</li>
<li>从JDK1.7开始，逐渐开始去除永久代的工作：如，符号引用（Symbols）转移到了native heap，字面量iterned string转移到了java heap，类的静态变量（class statics）转移到了java heap</li>
<li>这部分比较乱，按照原来的说法，应当是：用于存放静态文件，如Java类，方法等。对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class</li>
</ul>
<h3 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h3><ol>
<li>JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域</li>
<li>当Eden区空间足够时，内存申请结束。否则执行下一步</li>
<li>JVM试图<em>释放在Eden区中所有不活跃的对象（Young GC）</em>。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区</li>
<li>Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被转移到年老代</li>
<li>当年老代空间不足够时，JVM会在年老代进行完全的垃圾回收（Full GC）</li>
<li>Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生的对象申请内存，即出现OutofMemory</li>
</ol>
<h3 id="对象分配原则"><a href="#对象分配原则" class="headerlink" title="对象分配原则"></a>对象分配原则</h3><ul>
<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，<em>虚拟机执行一次Minor GC</em></li>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个survivor区之间发生大量的内存拷贝(<em>新生代采用复制算法收集内存</em>)</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC，那么对象会进入Survivor区，之后每经过一次Minor GC，那么对象的年龄会加1,知道达到阈值，对象进入老年区</li>
<li><em>动态判断对象的年龄</em>，对象的年龄达到了MaxTenuring Threshold可以进入老年代。<ul>
<li>如果在survivor区中相同年龄所有对象大小的总和大于survivor区的一半，则年龄大于等于该年龄的对象就可以直接进入到老年代，无需等到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
<li><em>空间分配担保。</em>每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小，则进行一次Full GC，如果小于检查handlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC</li>
</ul>
<h2 id="对象存活的判断"><a href="#对象存活的判断" class="headerlink" title="对象存活的判断"></a>对象存活的判断</h2><p>判断对象是否存活的两种方式：  </p>
<ul>
<li>引用计数:每个对象有一个引用计数属性，新增一个引用时计数加1,引用释放时计数减1.计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题</li>
<li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索走过的路径称为引用链。当一个对象到GC Roots，没有任何引用链相连时，则证明此对象是不可用的，不可达对象。<br>在Java语言中，GC Roots包括：  </li>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性实体引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<p>##垃圾收集算法</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174234266-1575111287.png" alt=""><br>“标记-清除”（Mark-Sweep）：</p>
<ul>
<li>首先标记出所有需要回收的对象</li>
<li>在标记完成后，统一回收掉所有被标记的对象<br>缺点：</li>
<li>效率问题：标记和清除的过程，效率都不高</li>
<li>空间问题：会产生大量不连续的内存碎片<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174237703-328169343.png" alt=""><br>复制copying收集算法：  </li>
<li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块</li>
<li>当一块内存用完了，就将还存活着的对象复制到另外一块上面，然后将已使用过的内存空间一次清理掉<br>优缺点：</li>
<li>优点：没有内存碎片问题</li>
<li>缺点：内存缩小为原来的一半，持续复制长生存期的对象将导致效率降低<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239219-1187241876.png" alt=""><br>标记-整理（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<em>让所有存活的对象都向一端移动</em>，然后直接清理掉端边界以外的内存<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3>GC分代的基本假设：绝大部分对象的生命周期都非常短，存活时间短<br>“分代收集（Generational Collection）”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。  </li>
<li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<em>复制算法</em>，只需要付出少量存活对象的复制成本，就可以完成收集</li>
<li>在老年代，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“表细-清除”，或“标记-整理”算法来进行回收</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="不是最后的最后"><a href="#不是最后的最后" class="headerlink" title="不是最后的最后"></a>不是最后的最后</h3><p>这部分没有烂尾，但是目前真的就先写到这里了。后续不仅仅要把垃圾收集器补充上，还要把调优的过程实现，有代码的实践过程，再写这部分内容，才会更加深刻而有意义。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>基于JVM服务器的性能优化方法 <a href="https://www.google.com/patents/CN103186412A?cl=zh" target="_blank" rel="external">https://www.google.com/patents/CN103186412A?cl=zh</a></li>
<li>JVM内存分配策略<a href="http://www.cnblogs.com/z-sm/p/6252245.html" target="_blank" rel="external">http://www.cnblogs.com/z-sm/p/6252245.html</a></li>
<li>Java GC算法 垃圾回收器<a href="http://www.importnew.com/23752.html" target="_blank" rel="external">http://www.importnew.com/23752.html</a></li>
</ul>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/JVM/">JVM</a>
          
        </div>

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2017/03/15/stackandheap/">
        <span class="next-text nav-default">堆和栈</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2016 -
    
    2017
    <span class="footer-author">Rivers Yung.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo </a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
